import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unnecessary_brace_in_string_interps

//WARNING: This file is automatically generated. DO NOT EDIT, all your changes would be lost.

typedef LocaleChangeCallback = void Function(Locale locale);

class I18n implements WidgetsLocalizations {
  const I18n();
  static Locale _locale;
  static bool _shouldReload = false;

  static set locale(Locale newLocale) {
    _shouldReload = true;
    I18n._locale = newLocale;
  }

  static const GeneratedLocalizationsDelegate delegate = GeneratedLocalizationsDelegate();

  /// function to be invoked when changing the language
  static LocaleChangeCallback onLocaleChanged;

  static I18n of(BuildContext context) =>
    Localizations.of<I18n>(context, WidgetsLocalizations);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  /// "GOVM"
  String get appName => "GOVM";
  /// "Home"
  String get home => "Home";
  /// "Transaction"
  String get transaction => "Transaction";
  /// "History"
  String get history => "History";
  /// "Setting"
  String get setting => "Setting";
  /// "64-bit hexadecimal plaintext"
  String get wDesc1 => "64-bit hexadecimal plaintext";
  /// "Change"
  String get change => "Change";
  /// "Wrong private key, must be a 64-bit hexadecimal string"
  String get wDesc2 => "Wrong private key, must be a 64-bit hexadecimal string";
  /// "successful, please make sure you have remembered the private key"
  String get wSeccess => "successful, please make sure you have remembered the private key";
  /// "remember the private key and login again"
  String get wLogin => "remember the private key and login again";
  /// "Log In"
  String get login => "Log In";
  /// "Reset wallet"
  String get resetWallet => "Reset wallet";
  /// "Mnemonics separated by spaces"
  String get wDesc3 => "Mnemonics separated by spaces";
  /// "Wrong mnemonic"
  String get wDesc4 => "Wrong mnemonic";
  /// "Load Wallet"
  String get loadWallet => "Load Wallet";
  /// "Description"
  String get description => "Description";
  /// "Plaintext private key"
  String get privateKey => "Plaintext private key";
  /// "Mnemonic"
  String get mnemonic => "Mnemonic";
  /// "Info"
  String get info => "Info";
  /// "OK"
  String get ok => "OK";
  /// "Cancel"
  String get cancel => "Cancel";
  /// "Are you sure to reset the wallet?"
  String get resetMsg => "Are you sure to reset the wallet?";
  /// "Transaction history"
  String get transHistory => "Transaction history";
  /// "Transfer In"
  String get tranferIn => "Transfer In";
  /// "Transfer Out"
  String get tranferOut => "Transfer Out";
  /// "Move"
  String get move => "Move";
  /// "no record"
  String get noRecord => "no record";
  /// "Chain"
  String get chain => "Chain";
  /// "QR Code"
  String get qrCode => "QR Code";
  /// "Account"
  String get account => "Account";
  /// "Copy Address"
  String get copyAddr => "Copy Address";
  /// "Version"
  String get version => "Version";
  /// "WebSite"
  String get website => "WebSite";
  /// "ApiServer"
  String get apiServer => "ApiServer";
  /// "Transfer"
  String get transfer => "Transfer";
  /// "Peer Address"
  String get peerAddr => "Peer Address";
  /// "wrong address"
  String get addrError => "wrong address";
  /// "Cannot be less than 0"
  String get lessThan0 => "Cannot be less than 0";
  /// "Must be number"
  String get mustNum => "Must be number";
  /// "Wrong cost"
  String get eCost => "Wrong cost";
  /// "Not enough coins"
  String get noMoney => "Not enough coins";
  /// "Submit"
  String get submit => "Submit";
  /// "From Chain equal To Chain"
  String get equalChain => "From Chain equal To Chain";
  /// "fail"
  String get fail => "fail";
  /// "Warning: When replacing the private key, the old private key will not be saved. If you do not save it in advance, it will be permanently lost."
  String get walletWarning1 => "Warning: When replacing the private key, the old private key will not be saved. If you do not save it in advance, it will be permanently lost.";
  /// "Plaintext private key: a 64-bit hexadecimal hash string. The private key does not exist in the network, but is generated by the user and stored in a file."
  String get walletWarning2 => "Plaintext private key: a 64-bit hexadecimal hash string. The private key does not exist in the network, but is generated by the user and stored in a file.";
  /// "The private key can provide a signature for the transaction. If the private key is leaked, the corresponding account is not secure."
  String get walletWarning3 => "The private key can provide a signature for the transaction. If the private key is leaked, the corresponding account is not secure.";
  /// "Mnemonic: Another form of expressing private keys in plaintext, first proposed by the BIP39 proposal, can help users remember complex private keys."
  String get walletWarning4 => "Mnemonic: Another form of expressing private keys in plaintext, first proposed by the BIP39 proposal, can help users remember complex private keys.";
  /// "Refresh"
  String get refresh => "Refresh";
  /// "Create private key first"
  String get needWallet => "Create private key first";
  /// "balance"
  String get balance => "balance";
  /// "chain${id} balance:"
  String chainBalance(String id) => "chain${id} balance:";
  /// "freeze"
  String get freeze => "freeze";
  /// "Total assets"
  String get totalAssets => "Total assets";
  /// "Wallet Address"
  String get walletAddress => "Wallet Address";
  /// "unit"
  String get unit => "unit";
  /// "Chain${id}"
  String chainID(String id) => "Chain${id}";
  /// "From:Chain${id}"
  String fromChain(String id) => "From:Chain${id}";
  /// "To:Chain${id}"
  String toChain(String id) => "To:Chain${id}";
  /// "Cross-chain transfer. Move coins to other chain, need wait 10 min after accepted."
  String get moveDesc => "Cross-chain transfer. Move coins to other chain, need wait 10 min after accepted.";
  /// "Wallet Password"
  String get password => "Wallet Password";
  /// "password wrong"
  String get ePassword => "password wrong";
  /// "vote"
  String get vote => "vote";
  /// "Cancel Vote"
  String get cancelVote => "Cancel Vote";
  /// "votes"
  String get votes => "votes";
  /// "admin"
  String get admin => "admin";
  /// "end"
  String get end => "end";
}

class _I18n_en_US extends I18n {
  const _I18n_en_US();

  @override
  TextDirection get textDirection => TextDirection.ltr;
}

class _I18n_zh_CN extends I18n {
  const _I18n_zh_CN();

  /// "GOVM"
  @override
  String get appName => "GOVM";
  /// "主页"
  @override
  String get home => "主页";
  /// "交易"
  @override
  String get transaction => "交易";
  /// "历史"
  @override
  String get history => "历史";
  /// "设置"
  @override
  String get setting => "设置";
  /// "64位16进制明文"
  @override
  String get wDesc1 => "64位16进制明文";
  /// "换一个"
  @override
  String get change => "换一个";
  /// "错误私钥,必须是64位16进制的字符串"
  @override
  String get wDesc2 => "错误私钥,必须是64位16进制的字符串";
  /// "钱包切换成功，请确保已经记住私钥"
  @override
  String get wSeccess => "钱包切换成功，请确保已经记住私钥";
  /// "记住私钥并重新登录"
  @override
  String get wLogin => "记住私钥并重新登录";
  /// "登录"
  @override
  String get login => "登录";
  /// "重置钱包"
  @override
  String get resetWallet => "重置钱包";
  /// "助记词以空格分隔"
  @override
  String get wDesc3 => "助记词以空格分隔";
  /// "错误的助记词"
  @override
  String get wDesc4 => "错误的助记词";
  /// "导入钱包"
  @override
  String get loadWallet => "导入钱包";
  /// "说明"
  @override
  String get description => "说明";
  /// "明文私钥"
  @override
  String get privateKey => "明文私钥";
  /// "助记词"
  @override
  String get mnemonic => "助记词";
  /// "消息"
  @override
  String get info => "消息";
  /// "确认"
  @override
  String get ok => "确认";
  /// "取消"
  @override
  String get cancel => "取消";
  /// "你确定要重置钱包吗？"
  @override
  String get resetMsg => "你确定要重置钱包吗？";
  /// "交易历史"
  @override
  String get transHistory => "交易历史";
  /// "转入"
  @override
  String get tranferIn => "转入";
  /// "转出"
  @override
  String get tranferOut => "转出";
  /// "跨链转账"
  @override
  String get move => "跨链转账";
  /// "无记录"
  @override
  String get noRecord => "无记录";
  /// "链"
  @override
  String get chain => "链";
  /// "二维码"
  @override
  String get qrCode => "二维码";
  /// "账户"
  @override
  String get account => "账户";
  /// "复制地址"
  @override
  String get copyAddr => "复制地址";
  /// "版本"
  @override
  String get version => "版本";
  /// "官网"
  @override
  String get website => "官网";
  /// "接口服务器"
  @override
  String get apiServer => "接口服务器";
  /// "转账"
  @override
  String get transfer => "转账";
  /// "对方地址"
  @override
  String get peerAddr => "对方地址";
  /// "地址错误"
  @override
  String get addrError => "地址错误";
  /// "不能小于0"
  @override
  String get lessThan0 => "不能小于0";
  /// "只能是数字"
  @override
  String get mustNum => "只能是数字";
  /// "金额不对"
  @override
  String get eCost => "金额不对";
  /// "钱不够"
  @override
  String get noMoney => "钱不够";
  /// "提交"
  @override
  String get submit => "提交";
  /// "链ID相同"
  @override
  String get equalChain => "链ID相同";
  /// "错误"
  @override
  String get fail => "错误";
  /// "警告：替换私钥时，旧的私钥不会保存，如果你没有事先保存，将永久丢失。"
  @override
  String get walletWarning1 => "警告：替换私钥时，旧的私钥不会保存，如果你没有事先保存，将永久丢失。";
  /// "明文私钥：样式为64位16进制的哈希字符串。私钥不存在网络中，而是由用户生成并存储在文件中，称为钱包文件。"
  @override
  String get walletWarning2 => "明文私钥：样式为64位16进制的哈希字符串。私钥不存在网络中，而是由用户生成并存储在文件中，称为钱包文件。";
  /// "私钥可以为交易提供签名，如果私钥泄露，那么对应的账户也不安全。"
  @override
  String get walletWarning3 => "私钥可以为交易提供签名，如果私钥泄露，那么对应的账户也不安全。";
  /// "助记词： 明文私钥的另一种表现形式，最早由BIP39提案提出，可以帮组用户记忆复杂的私钥。"
  @override
  String get walletWarning4 => "助记词： 明文私钥的另一种表现形式，最早由BIP39提案提出，可以帮组用户记忆复杂的私钥。";
  /// "刷新"
  @override
  String get refresh => "刷新";
  /// "请先创建钱包私钥"
  @override
  String get needWallet => "请先创建钱包私钥";
  /// "余额"
  @override
  String get balance => "余额";
  /// "链${id}余额："
  @override
  String chainBalance(String id) => "链${id}余额：";
  /// "冻结"
  @override
  String get freeze => "冻结";
  /// "总资产"
  @override
  String get totalAssets => "总资产";
  /// "钱包地址"
  @override
  String get walletAddress => "钱包地址";
  /// "货币单位"
  @override
  String get unit => "货币单位";
  /// "链${id}"
  @override
  String chainID(String id) => "链${id}";
  /// "从链${id}转出"
  @override
  String fromChain(String id) => "从链${id}转出";
  /// "转到链${id}"
  @override
  String toChain(String id) => "转到链${id}";
  /// "跨链转账，被接收后还需要等10分钟"
  @override
  String get moveDesc => "跨链转账，被接收后还需要等10分钟";
  /// "钱包密码"
  @override
  String get password => "钱包密码";
  /// "密码错误"
  @override
  String get ePassword => "密码错误";
  /// "投票"
  @override
  String get vote => "投票";
  /// "取消投票"
  @override
  String get cancelVote => "取消投票";
  /// "选票"
  @override
  String get votes => "选票";
  /// "管理员"
  @override
  String get admin => "管理员";
  /// "end"
  @override
  String get end => "end";

  @override
  TextDirection get textDirection => TextDirection.ltr;
}

class GeneratedLocalizationsDelegate extends LocalizationsDelegate<WidgetsLocalizations> {
  const GeneratedLocalizationsDelegate();
  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale("en", "US"),
      Locale("zh", "CN")
    ];
  }

  LocaleResolutionCallback resolution({Locale fallback}) {
    return (Locale locale, Iterable<Locale> supported) {
      if (isSupported(locale)) {
        return locale;
      }
      final Locale fallbackLocale = fallback ?? supported.first;
      return fallbackLocale;
    };
  }

  @override
  Future<WidgetsLocalizations> load(Locale locale) {
    I18n._locale ??= locale;
    I18n._shouldReload = false;
    final String lang = I18n._locale != null ? I18n._locale.toString() : "";
    final String languageCode = I18n._locale != null ? I18n._locale.languageCode : "";
    if ("en_US" == lang) {
      return SynchronousFuture<WidgetsLocalizations>(const _I18n_en_US());
    }
    else if ("zh_CN" == lang) {
      return SynchronousFuture<WidgetsLocalizations>(const _I18n_zh_CN());
    }
    else if ("en" == languageCode) {
      return SynchronousFuture<WidgetsLocalizations>(const _I18n_en_US());
    }
    else if ("zh" == languageCode) {
      return SynchronousFuture<WidgetsLocalizations>(const _I18n_zh_CN());
    }

    return SynchronousFuture<WidgetsLocalizations>(const I18n());
  }

  @override
  bool isSupported(Locale locale) {
    for (var i = 0; i < supportedLocales.length && locale != null; i++) {
      final l = supportedLocales[i];
      if (l.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => I18n._shouldReload;
}